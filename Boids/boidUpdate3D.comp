#version 450

#define timeStep 0.0167

#define perceptionRange 0.1

#define perceptionFOV radians(120)

#define EPS 0.002

#define g 1.0


layout(std430, push_constant) uniform pushConstants {
    uint flockSize;
    float cohesionConstant;
    float alignmentConstant;
    float separationConstant;
};

layout(std430, binding = 0) readonly buffer posInSSBO {
    vec3 posIn[];
};

layout(std430, binding = 1) readonly buffer velInSSBO {
    vec3 velIn[];
};

layout(std430, binding = 2) buffer posOutSSBO {
    vec3 posOut[];
};

layout(std430, binding = 3) buffer velOutSSBO {
    vec3 velOut[];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

float positiveQuadraticRoot(float a, float b, float c)
{

    return (-b + sqrt(b*b - 4 * a * c)) / (2 * a);
}

// Clamps magnitude to 1
vec3 clampedAdd(vec3 u, vec3 v)
{

    if (dot(u, u) > 1.0)
        return normalize(u);

    if (dot(v, v) < 0.01)
        return u;

    float x = positiveQuadraticRoot(dot(v, v), 2 * dot(u, v), dot(u, u) - 1);

    return u + min(x, 1) * v;
}

bool outsidePerception(vec3 relativePos, vec3 velSelf)
{

    return (length(relativePos) > perceptionRange) || (dot(normalize(relativePos), normalize(velSelf)) < cos(perceptionFOV));
}

vec3 velocityUpdate(uint index)
{

    uint localPop = 0;

    vec3 localAvgPos = vec3(0.0, 0.0, 0.0);

    vec3 localAvgVel = vec3(0.0, 0.0, 0.0);

    vec3 separation = vec3(0.0, 0.0, 0.0);

    for (int j = 0; j < flockSize; j++)
    { 

        vec3 r = posIn[j] - posIn[index];

		if ((j != index) && (!outsidePerception(r, velIn[index])))
        {

        localAvgPos += r;

        localAvgVel += velIn[j];

        separation -= normalize(r) / pow(3 * length(r) / perceptionRange, 3);

        localPop++;
        }
    }

    if (localPop > 0)
    {

		localAvgPos /= localPop;

		localAvgVel /= localPop;
	}

    vec3 cohesion = localAvgPos;

    vec3 alignment = localAvgVel - velIn[index];

    vec3 force = vec3(0.0, 0.0, 0.0);

	force = clampedAdd(force, separationConstant * separation);

	force = clampedAdd(force, alignmentConstant * alignment);

	force = clampedAdd(force, cohesionConstant * cohesion);

    float speed = clamp(2 * posIn[index].z * g, 0.05, 0.25);

    return speed * normalize(velIn[index] + force * timeStep);
}

float circular(float x)
{

    if (x > 1)
        x -= 2;
    else if (x < -1)
        x += 2;

    return x;
}

vec3 tile(vec3 v)
{

    return vec3(circular(v.x), circular(v.y), v.z);
}

void main()
{

    uint index = gl_GlobalInvocationID.x;

    if (index >= flockSize)
        return;

    posOut[index] = posIn[index] + timeStep * velIn[index];

    posOut[index] = tile(posOut[index]);

    velOut[index] = velocityUpdate(index);
}